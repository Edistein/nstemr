# ARM64汇编（一）：立即数编码模式和寻址模式汇总

<small>《Windows x86 shellcode研究》第三篇仍然鸽着。最麻烦的是我已经基本忘记当时想写什么了... 当然，开学前会尽量把坑全部填上。</small>

因为有需求，这两天集中讨论一下A64/A32指令集相关的东西。

<br>

## ARM汇编中立即数编码模式的必要性

我们知道，ARM和ARM64架构CPU的指令集（A32和A64）都是定长指令。如果立即数只能通过简单地嵌入指令中来给出，我们就会陷入一对非常不好的抉择：

*   如果要容下足够大范围的立即数，所有指令都会不必要地变得很长；
 
    比如为了保证能嵌入任何32bit立即数，整个指令集里所有指令的长度当然就必须大于32bit。
    
*   要么为了保证每条指令的长度足够简短，立即数的范围就会非常小；

    比如为了保证每条指令长度都只有32bit，那么假设其中20bit分配给了操作码和其他操作数，就只剩下12bit = [0, 4096) 的立即数范围了。

由于指令长度是更基本的限制，牵涉到硬件设计和性能的方方面面，因此从大方向上来说，A32和A64指令集都从第二种方案出发。

但是对方案二而言，这个[0, 4096)的范围还是比较小。所以，除了傻乎乎地让12bit数据直接以二进制数的方式直接映射到十进制数之外，需要其他计算模式以扩展范围。

<br>

## 立即数编码模式的一个简单例子

最简单也最容易想到的例子是4/8字节对齐模式。虽然我们只有4096个不同的数值可以选择，但是注意——由于4字节对齐机制的存在，其实我们大部分时候只需要对4的整数倍地址进行寻址。**这意味着在4字节对齐的情况下，当一个立即数以地址/地址偏移的形式存在时，它的低2位始终是0。**这意味着低二位作可以被忽略，12bit立即数可以只用来表示从第三位开始的二进制位。从而，立即数寻址范围从[0, 4096)扩展到了65536。

当然，除了这种简单的倍乘映射，还存在着许多其他立即数扩展方法，下面简单汇总。

<br>

## 寻址模式汇总

### 1. 寄存器寻址

A64指令集允许以一个64位寄存器作为基地址，加上另一个64位寄存器的地址来寻址。另外，还可以通过一个32位寄存器进行移位、放缩等操作。

### 2. PC相对寻址（分支跳转）

* 可以对PC寄存器上下1MB范围内的地址进行寻址。
* 基于process state flag或者比较的条件跳转范围为上下1MB，位相关的条件跳转范围为上下32KB.
* 无条件跳转（包括链接）范围是上下128MB。

### 3. LD和ST寻址模式

LD和ST相关的指令需要：

* 从通用寄存器/栈寄存器中得到的基地址；
* （可选）一个相对基地址的偏移量。

支持的语法包括（`base`指代提供基地址的寄存器）：
* `[base]`。这玩意等价于`[base, #0]`，也就是不偏移；
*   `[base, #imm]`。基地址+偏移量，即寻址结果为`[base] + #imm`；
    `[base, Xm]`。基地址+偏移量，即寻址结果为`[base] + #imm`；
* `[base, #imm]!`。基地址-偏移量

（仍在施工中）





















<br><br><br><br><br><br>
<hr>

### [目录](./index.md)
### [首页](../index.html)