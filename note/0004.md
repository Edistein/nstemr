# QQ核心Api：TLV协议和TEA算法

<small>之前挖坑的《Windows x86 shellcode研究（三）》自从考试开始复习之后，就一直没动力写（因为考完之后就没再研究这个问题了）。估计会一直这样鸽下去...</small>


## TLV协议简介

TLV协议是一种简单的传输协议，名字里的三个字母分别代表Tag, Length, Value的缩写，而它们同时也是TLV数据包中的三个主要字段。其中，Tag可以指示数据包的种类；Length指示了Value字段的长度；Value字段是数据包的主要内容。

根据网络上的资料，QQ采用的TLV协议，Tag和Length都是2字节长度。所以之后也将只讨论这个大小的TLV数据包。

## 实现基础设施
根据这些知识，可以写出一个简单的TLV结构模板类：

```csharp
    public class Tlv
    {
        public ushort Tag { get; }
        public ushort Length { get; private set; }
        //Index可以为下面的字典提供一个额外的键，用来保存值添加的顺序。只有有了这个顺序，才能把Values中的内容顺利序列化成字节数组
        private List<string> Index { get; } = new List<string>();
        //之所以使用字典，是因为这样就可以给每个Value分配一个唯一的名字，方便解析数据包后输出人类可读的字符串
        //Values理论上可以是任何类型，所以此处善用C#的dynamic特性
        private Dictionary<string, dynamic> Values { get; set; }
        //P.S.实际上更设计一点的做法是为Value专门创建一个类，同时保存值和对应的名字，这样就不需要字典+列表而只需要列表了。但是因为目前的情况也并没有增加很多复杂度，所以使用了现在的方案。
    }
```

接下来，需要给这个类添加最基本的添加值、清除值的方法。依然很直接：
```csharp
    public class Tlv
    {
        public void AddValue(string name, dynamic obj)
        {
            Index.Add(name);
            Values.Add(name, obj);
            //根据TLV协议的定义，长度需要跟随Value字段增长：
            Length += SizeOf(obj);
            //SizeOf()函数是扩展版的sizeof()，因为后者处理不了字节数组。
            //当SizeOf()的参数是字节数组时，它会直接返回数组的长度；如果是别的基础类型就会返回它们的字节长度。
        }
        public void ClearAllValues()
        {
            Index.Clear();
            Values.Clear();
            Length = 0;
        }//这个没啥好说的
    }
```

## 二进制化和反二进制化

这才是问题的核心。

首先，注意对于不同类型的数据，内置的`BitConverter`类型需要调用不同的方法；另一方面，对于不同的Tag，QQ有一套完整的、各不相同Value定义。这意味着反二进制化时，程序必须有相应的类型信息。

因此，我设计了一个简单的、用字符串注解不同字段中Value的名称与类型的方法。其语法为：

```bat
每个Value的信息可以这样表示：
[值的名称]@[类型]

则整个Value字段的信息可以表示为：
[第一个值的名称]@[第一个值的类型],[第二个值的名称]@[第二个值的类型],...

其中，类型可以为：
us  代表 ushort
s   代表 short
ui  代表 uint
i   代表 int
b_x 代表 长度为x的字节数组
```

例如，根据网上的资料，QQ协议中Tag值为0x18的TLV数据包（简称Tlv18，其它同理）的Value字段含义为：
```c
0x0001 //1 固定值
0x00000600 //固定值
0x00000010 //第一个参数
0x00000000 //第二个参数
0x00bc614e //第三个参数 qq 
0x0000 //第四个参数
0x0000 //固定值
```

那么根据上面设计的语法，Tlv18的Value字段布局，可以用以下字符串描述：
```csharp
string layout_18 = "固定值0x1@us,固定值0x600@ui,参数@ui,参数@ui,QQ@ui,参数@us,参数@us";
```

从而，程序可以通过解析该字符串，知道如何正确从一堆字节中，反二进制化出对应的数据，既不漏过也不溢出。

由于对于每一种可能的Tag值，Value的布局都大相径庭，因此不妨维护一个静态字段，其中保存了所有已知Tag值对应的Value布局：
```csharp
private static readonly Dictionary<ushort, string> Layouts =new Dictionary<ushort, string> 
{
    //tag, "[name0]type0,[name1]type1..."
    { 0x18, "固定值1@us,固定值2@ui,未知参数1@ui,未知参数2@ui,QQ@ui,未知参数3@us,未知参数4@us" },
    { 0x01, "固定值1@us,随机值@ui,QQ@ui,系统时间@ui,固定值2@us,补零@ui"},
    { 0x106, "加密数据@b_112"}
    //这个字典可以不断延伸
};
```

这样一来，解析器只需要先提取Tag字段，然后查这个字典就能得到Value字段的布局，从而实现进一步功能。

有了这个字典，来看看反二进制化，即“将一个TLV数据包中的数据，加载到一个TLV对象中”。

不妨先实现一个可以根据类型字符串，转换相应长度的字节数组到C#对象的函数。有了它，之后只需要连续调用即可：
```csharp
private dynamic GetValue(byte[] bin, int index, stringtype_str)
{
    if (type_str == "us")
        return BitConverter.ToUInt16(bin.SubArray(index, 2).ReverseArray(), 0);
    else if (type_str == "s")
        return BitConverter.ToInt16(bin.SubArray(index, 2).ReverseArray(), 0);
    else if (type_str == "ui")
        return BitConverter.ToUInt32(bin.SubArray(index, 4).ReverseArray(), 0);
    else if (type_str == "i")
        return BitConverter.ToInt32(bin.SubArray(index, 4).ReverseArray(), 0);
    else if (type_str.StartsWith("b"))
    {
        int array_len = Convert.ToInt32(type_str.Split('_')[1]);
        byte[] array = new byte[array_len];
        for (int n = 0; n < array_len; n++)
        {
            array[n] = bin[Length];
            Length++;
        }
        return array;
    }
    else throw new Exception($"无法反序列化字节数组：Value中遇到未知类型'{type_str}'");
}
//ReverseArray()和SubArray()都是工具性质的扩展方法
//byte[].ReverseArray() 等价于 byte[].Reverse().ToArray(); 
//byte[].SubArray()用法类似string.SubString()

//之所以要反转是因为数据包中的字节序是网络序（大端序），而BitConverter是小端序。
//所以每个字节片段都要先反转才能送入BitConverter.ToXXX()函数
```

利用这个函数，就可以写出简洁的反二进制化函数了：
```csharp
public void LoadData(byte[] bin)
{
    //因为Length是可以计算的，所以可以先做一些基本的校验
    ushort tag = (ushort)GetValue(bin, 0, "us");
    if (!Layouts.ContainsKey(tag))
        throw new Exception($"未知Tlv类型0x{tag:x2}");//出这个异常说明Layouts需要更新了
    if (Tag != tag)
        throw new Exception("无法反序列化字节数组：当前Tag类型与数据中的Tag类型不符");
    ushort length = (ushort)GetValue(bin, sizeof(ushort), "us");
    if (length != bin.Length - 2*sizeof(ushort))
        throw new Exception("无法反序列化字节数组：数据中的Length与实际Value长度不符");
    //校验通过，导入数据
    ClearAllValues();
    string[] value_info_list = Layouts[tag].Split(',');
    for (int i = 0; i < value_info_list.Length; i++)
    {
        var ntp = value_info_list[i].Split('@');
        string name = ntp[0];
        string type_str = ntp[1];
        AddValue(name, GetValue(bin, Length+sizeof(ushort)*2, type_str));
    }
    //结束校验
    if (Length != length) throw new Exception("错误：反序列化后的实际Length与数据的Length不符");
}
```

相同函数还可以放进构造函数里，从而提供一种直接从二进制序列生成数据包对象的方法。唯一区别是这种情况下Tag的验证可以忽略，因为Tag当然是只能从数据里读取的。
```csharp
public Tlv(byte[] bin)
{
    Tag = (ushort)GetValue(bin, 0, "us");
    Length = 0;
    Values = new Dictionary<string, dynamic>();

    if (!Layouts.ContainsKey(Tag))
        throw new Exception($"未知Tlv类型0x{Tag:x2}");
    ushort length = (ushort)GetValue(bin, sizeof(ushort), "us");
    if (length != bin.Length - 2 * sizeof(ushort))
        throw new Exception("无法反序列化字节数组：数据中的Length与实际Value长度不符");
    //校验通过，导入数据
    string[] value_info_list = Layouts[Tag].Split(',');
    for (int i = 0; i < value_info_list.Length; i++)
    {
        var ntp = value_info_list[i].Split('@');
        string name = ntp[0];
        string type_str = ntp[1];
        AddValue(name, GetValue(bin, Length + sizeof(ushort) * 2, type_str));
    }
    //结束校验
    if (Length != length) throw new Exception("反序列化后的实际Length与数据的Length不符");
}
```

反序列化同理，定义工具函数`GetBytes()`，然后根据`Index`中的顺序依次输出到字节数组中。

最后，可以利用Values字典设计`ToString()`函数，将数据包内容转化为对人类友好的字符串：
```csharp
public override string ToString()
{
    string re = "";
    re += $"Tag: 0x{Tag:x4}\n";
    re += $"Length: 0x{Length:x4}\n";
    for (int i = 0; i < Index.Count; i++)
    {
        string name = Index[i];
        if (Values[name] is ushort || Values[name] is short)
            re += $"Value[{i}]: {name}  0x{Values[name]:x4}\n";
        else if (Values[name] is uint || Values[name] is int)
            re += $"Value[{i}]: {name}  0x{Values[name]:x8}\n";
        else if (Values[name] is byte[] bin)
            re += $"Value[{i}]: {name}  {bin.ToHexString()}\n";
    }
    return re;
}
```

若数据包内容为
```text
00180016000100000600000000100000000000bc614e00000000
```

则可以用以下小程序测试序列化-反序列化功能，以及查看数据包内容：
```csharp
string test_str ="00180016000100000600000000100000000000bc614e00000000";
Tlv tlv18_test = new Tlv(test_str.ToByteArray());
//ToByteArray()可以把特定分隔符的十六进制字符串转换为字节数组
Console.WriteLine(tlv18_test.ToString());
Console.WriteLine(tlv18_test.ExportData().ToHexString());
//ToHexString()可以用特定分隔符拼接字节数组并合成字符串
Console.WriteLine(test_str);
Console.ReadKey();

//      输出：
//      Tag: 0x0018
//      Length: 0x0016
//      Value[0]: 固定值1  0x0001
//      Value[1]: 固定值2  0x00000600
//      Value[2]: 未知参数1  0x00000010
//      Value[3]: 未知参数2  0x00000000
//      Value[4]: QQ  0x00bc614e
//      Value[5]: 未知参数3  0x0000
//      Value[6]: 未知参数4  0x0000
//      
//      00180016000100000600000000100000000000bc614e00000000
//      00180016000100000600000000100000000000bc614e00000000
```
从最后两行可以看到，原始数据和经历序列化-反序列化后的数据完全一致。TLV协议的主要基础设施到这里就基本实现完全了。

之所以说**基本上**，是因为根据QQ的协议，有些种类的TLV数据包（例如Tlv106），其Value字段是加密的。这时如果要反序列化，必须先解密。这就引出了本文的第二部分：QQ的TEA算法（以下简称qtea）。

<br>

## TEA算法简介

TEA是Tiny Encryption Algorithm的缩写。看名字就可以知道，这是一种非常精简的加密算法。实际上，写得比较恰当的实现通常可以在十行左右解决加密和解密。 

明文数据块大小为64位，即通常机器上的8字节。因此，一般的实现里用两个uint代替；密钥长度为128位，即16字节。

加密方法本身没什么好说的，总的来看只有两步位运算和加减。重点在于加密模式。TEA算法使用CBC模式，即每个数据块的密文会影响下个密文的输出，形成链条。

具体来说，每个明文块的数据会先与上个密文块的数据异或，然后才加密得到密文。这样，即使简单的加密计算方法也会因为链条的传递性而产生雪崩效应，从而破除数据和密文块中的简单映射关系。

知道了这一点，在具体实现的时候，容易想到将加/解密器和CBC加/解密模式分开实现。

## 加密器实现

<hr>

> 由于缺乏完整实现整个QQ协议的耐心，2021年7月机器人已经通过Http API和mirai项目复活，本项目失去存在的必要性，因此无限期搁置。

> 当然，无限期的意思是未来的某一天也许会继续。



















<br><br><br><br><br><br>
<hr>

### [目录](./index.md)
### [首页](../index.html)